# Extracted content
Source: subjects/Dbd/Teoria/Tema 4/Cuestiones _T4_sol.pdf

### Page 1
1
Diseño y Gestión de Bases de Datos
Solución Ejercicios Tema 4
1. x = 4, y = 2
T1: r(x)
  r(y)
  Si x>5 entonces x:= x-y
  Si no x:= x+y
  w(x)
  c
T2: r(x)
  x:= x+3
  w(x)
  c
• Plan T1-T2 → x=9, y = 2
• Plan T2-T1 → x=5, y = 2
2.
Lectura sucia: P= r1(x), w1(x), r2(x), w2(x), c2, a1

El grafo de seriabilidad no tiene ningún ciclo, el plan es serializable. El problema de la ‘lectura sucia’ reside
en el peligro de la ‘anulación en cascada’. Al anular T1 se debe anular en cascada T2 ya que ha leído (lectura
sucia) un dato actualizado por T1, que finalmente no ha sido confirmado.

Lectura no repetible
: P= r1(x), r2(x), w2(x), c2, r1(x), c1

El grafo tiene un ciclo, luego el plan P no es serializable.

Pérdida de actualizaciones: P= r
1(x), r2(x), w1(x), w2(x), c1, c2

El grafo tiene un ciclo, luego el plan P no es serializable.
![Page 1, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_001.png)
![Page 1, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_002.png)
![Page 1, Figure 3](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_003.png)
![Page 1, Figure 4](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_004.png)
![Page 1, Figure 5](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_005.png)
![Page 1, Figure 6](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_001_img_006.png)

### Page 2
Departamento de Sistemas Informáticos y Computación
          2
Concluyendo, en un plan serializable por conflictos podría aparecer la anomalía de lectura sucia, pero
nunca la de lectura no repetible  o pérdida de actualizaciones.  En estos dos últimos casos, el grafo de
seriabilidad siempre tiene un ciclo, y cuando el grafo tiene un ciclo, entonces el plan no es serializable por
conflictos.
3.
Plan P1: Operaciones en conflicto y grafo de seriabilidad en el plan P1:

Observamos que hay un ciclo. El plan no es serializable por conflictos.

Plan P2: Operaciones en conflicto y grafo de seriabilidad en el plan P2:

Observamos que hay un ciclo. El plan no es serializable por conflictos.

Plan P3: Operaciones en conflicto y grafo de seriabilidad en el plan P3:

Observamos que no hay ciclos. El plan es serializable por conflictos. El único plan en serie equivalente es:
T2 – T3 – T1
![Page 2, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_002_img_001.png)
![Page 2, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_002_img_002.png)
![Page 2, Figure 3](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_002_img_003.png)

### Page 3
Departamento de Sistemas Informáticos y Computación
          3

Plan P4: Operaciones en conflicto y grafo de seriabilidad en el plan P4:

Observamos que hay un ciclo. El plan no es serializable por conflictos.

Plan P5: Operaciones en conflicto y grafo de seriabilidad en el plan P5:

Se puede comprobar que el grafo es acíclico, por tanto, el plan es serializable por conflictos. Por otro
lado, analizando el grafo se puede deducir que el plan serial equivalente por conflictos es T2→T3→T4→T1.
En cuanto a las anomalías de la concurrencia que se dan en el plan, únicamente se presenta la lectura sucia,
como se puede ver en las correspondientes operaciones en conflicto que se dan en el plan, w
3(y) → r1(y),
w3(y) → r4(y) y w4(z) → r1(z)

4.
Lectura sucia: P= r1(x), w1(x), r2(x), w2(x), a1, c2

Como se puede observar en el ejemplo, el protocolo de bloqueo
B2F admite la anomalía de la ‘lectura sucia’ ya que es posible que una
transacción desbloquee elementos de datos antes de que finalice,
permitiendo, de este modo, que otras transacciones  lean los datos
modificados por ella aún no confirmados,.
Si el bloqueo fuera implícito no sería posible el desbloqueo
anterior a la finalización de la transacción, y no sería posible la
lectura sucia.
![Page 3, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_003_img_001.png)
![Page 3, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_003_img_002.jpeg)
![Page 3, Figure 3](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_003_img_003.png)

### Page 4
Departamento de Sistemas Informáticos y Computación
          4

Lectura no repetible:  P= r1(x), r2(x), w2(x), c2, r1(x), c1

Con B2F no se produce la lectura no repetible.
Como se puede observar al realizar el bloqueo de lectura T1
impide que T2 pueda bloquear para escritura el dato X. De esta
forma, al volver a leerlo, T1
 obtiene el mismo valor y no se produce
la lectura no repetible. El plan que se ejecuta (controlado por B2F)
es distinto al planteado:
P’ = r1(x), r1(x), r2(x), w2(x), c2, c1





Pérdida de actualizaciones: P= r
1(x), r2(x), w1(x), w2(x), c1, c2

Con B2F no se produce la pérdida de actualizaciones.
Si se realizaran primero BL para luego promoverlos a BE, se produce
el problema del bloqueo mortal.
Como se puede observar al realizar el bloqueo de escritura T1
impide que T2 pueda leer el dato X antes de que T1 lo haya modificado.
Cuando T1 desbloquea el dato X, T2 lee el valor modificado por T1,
impidiendo de esta forma que se pierda la actualización de T1. El plan
que se ejecuta (controlado por B2F) es distinto al planteado:
P’ = r1(x), w1(x), r2(x), w2(x), c1, c2


5. Cuando una transacción vaya a leer y escribir un dato, directamente se solicitará el BE sin pasar por el BL
de esta forma se evitan bloqueos mortales.
![Page 4, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_004_img_001.png)
![Page 4, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_004_img_002.png)
![Page 4, Figure 3](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_004_img_003.png)

### Page 5
Departamento de Sistemas Informáticos y Computación
          5
Hay que tener en cuenta que la solución que se plantea no es única, por ejemplo T1 podría haber
empezado con un bloqueo en lectura para X y promocionar ese bloqueo a escritura cuando lo necesite
porque va a escribir X.
6.


Plan A: con problema de anulación en cascada. T2 hace una lectura
sucia de T1, al anular esta última tiene que ser anulada en cascada T2.






Plan B: sin problema de anulación en cascada. T2 hace una
lectura sucia de T1, pero como esta última termina con confirmación
la lectura sucia no representa ningún problema.


7. Supongo que los elementos de datos X, Y, Z tienen marcas de tiempo de lectura y escritura menores que
las marcas de tiempo de las tres transacciones incluidas en el plan.
Plan P1:

En el instante t
9, la operación r 2(X) no puede realizarse, ya que X  tiene una marca de escritura que es
mayor que la marca de tiempo de T2 (i.e. ha sido escrito por una transacción más joven que T2). Por este
motivo el SGBD anularía T2 ejecutándola más adelante. El plan de ejecución P 1 no estaría permitido con el
protocolo OMT.
![Page 5, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_005_img_001.png)
![Page 5, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_005_img_002.png)
![Page 5, Figure 3](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_005_img_003.png)

### Page 6
Departamento de Sistemas Informáticos y Computación
          6
Plan P2:

En este caso el plan de ejecución P2 sí que estaría permitido por el protocolo OMT.
8. El plan visto a lo largo del tiempo sería:

Los protocolos tendrían el siguiente comportamiento:
• Protocolo B2F: este protocolo no permitiría el plan ya que T 1 quedaría en espera al solicitar el bloqueo
en escritura de y para la operación w1(y) porque T2 tiene que haber bloqueado para lectura Y antes de
la operación r2(y). Es decir, la confirmación de T1 nunca podría ocurrir antes de que T2 desbloquee Y.
![Page 6, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_006_img_001.png)
![Page 6, Figure 2](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_006_img_002.png)

### Page 7
Departamento de Sistemas Informáticos y Computación
          7
• Protocolo OMT: en este protocolo T 2 sería anulada al solicitar la operación w 2(y). En ese instante
MT_lectura(Y) = MT(T3) y MT_escritura(Y) = MT(T1) y dado que MT(T2)<MT(T1)<MT(T3) la transacción
T2 sería revertida.
• Protocolo MV: en este protocolo la transacción T 2 sería anulada al solicitar la operación de escritura
w2(y) ya que una transacción más joven (T1) ya ha leído Y.
9.  Veamos como es el diagrama temporal de ejecución de las transacciones:

Si nos fijamos en las transacciones que leen de otras, podremos deducir el tipo de plan de ejecución
desde el punto de vista de la recuperación. Podemos ver que T2 está leyendo de T3 (elemento B) y que T2
también está leyendo de T1 (elemento D). Además, T2 confirma después de T1 y antes que T3. Este segundo
hecho hace que el plan no sea recuperable (existe una transacción en el plan que lee de otra (lectura sucia)
y que confirma antes de que esta última finalice).
Proceso de recuperación: se debe deshacer las actualizaciones de la transacción T3 que ha sido
interrumpida por el fallo.  Deshacer T3 implica deshacer T 2 que hizo una lectura sucia de T3 y que ya fue
confirmada (plan no recuperable). Se deberá rehacer T1 que ha sido confirmada antes del fallo, y se supone,
después del último punto de control.
10.
a) MT(T1)= t
3, MT(T2)= t1 MT(T3)= t0
b) T3-T2-T1. Es el plan en serie cronológico: plan en serie en el que las transacciones se ejecutan en el
orden de sus marcas de tiempo.
c) t0:  MT_L(X) = t’ MT_E(X)=t0
t1:  MT_L(X) = t1 MT_E(X)=t0
t2:  MT_L(X) = t1 MT_E(X)=t1
t3:  MT_L(X) = t3 MT_E(X)=t1
t4:  MT_L(X) = t3 MT_E(X)=t1
t5:  MT_L(X) = t3 MT_E(X)=t3
t6:  La operación leer(X) de T3 se aborta ya que MT(T3) < MT_E(X) (t0 < t3). T3 debe revertirse
e introducirse de nuevo en el sistema.
En t 6 el protocolo ha detectado que T3 está intentando leer un dato modificado por una
transacción que en el plan en serie equivalente cronológico es más joven que ella.
![Page 7, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_007_img_001.png)

### Page 8
Departamento de Sistemas Informáticos y Computación
          8
11.
PROTOCOLO B2F Explícito
BL = Bloqueo de Lectura PB = Promoción del bloque de lectura a bloqueo de escritura  D = Desbloqueo
t T1 T2 T3
t10 BL(x)
t11 r1(x)
t12   BL(y)
t13   r3(y)
t14 PB(x)
t15 w1(x)
t16 BL(y)
t17 D(x)
t18  BL(x)
t19  r2(x)
t20 r1(y)
t21 D(y)
t22   PB(y)
t23   w3(y)
t24 c1
t25  PB(x)
t26  w2(x)
t27  D(x)
t28   BL(x)
t29   r3(x)
t30  c2
t31   D(x)
t32   D(y)
t33   c3
El protocolo B2F Explícito sí que acepta este plan de ejecución.
PROTOCOLO B2F Implícito
t T1 T2 T3
t10 r1(x) [implica BL(x)]
t11   r3(y) [implica BL(y)]
t12 w1(x) [implica PB(x)]
t13  r2(x) Pasa a ESPERA

En el protocolo B2F Implícito, el plan no es posible ya que la lectura de x por T2 no podrá ocurrir antes de
que se confirme T1 liberando entonces x.
![Page 8, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_008.png)

### Page 9
Departamento de Sistemas Informáticos y Computación
          9
PROTOCOLO Ordenamiento por Marcas de tiempo (OMT)
Supongo que tanto x como y tienen unas marcas iniciales a t 0 y que si i < j entonces t i < tj. También supongo
que el plan empieza en t10.
  Marcas de tiempo
X Y
t T1 T2 T3 ML ME ML ME
t9    t0 t0 t0 t0
t10 r1(x)   t10 t0 t0 t0
t11   r3(y) t10 t0 t11 t0
t12 w1(x)   t10 t10 t11 t0
t13  r2(x)  t13 t10 t11 t0
t14 r1(y)   t13 t10 t11 t0
t15   w3(y) t13 t10 t11 t11
t16 c1   t13 t10 t11 t11
t17  w2(x)  t13 t13 t11 t11
t18   r3(x)
El protocolo de ordenación por marcas de tiempo no acepta el plan ya que en el instante t18 la transacción T3
intenta leer un elemento de datos que ha sido escrito por una transacción más joven (MT_E(x) > MT(T3)).
PROTOCOLO Multiversión (MV)
Supongo que tanto x1 como y1 tienen unas marcas iniciales a t0 y que si i < j entonces ti < tj. También supongo
que el plan empieza en t10.
    Marcas de tiempo
    X1 Y1 X2 Y2 X3
    ML ME ML ME ML ME ML ME ML ME
t T1 T2 T3 t0 t0 t0 t0
t10 r1(x)   t10 t0 t0 t0
t11   r3(y) t10 t0 t11 t0
t12 w1(x)   t10 t0 t11 t0 t10 t10
t13  r2(x)  t10 t0 t11 t0 t13 t10
t14 r1(y)   t10 t0 t11 t0 t13 t10
t15   w3(y) t10 t0 t11 t0 t13 t10 t11 t11
t16 c1   t10 t0 t11 t0 t13 t10 t11 t11
t17  w2(x)  t10 t0 t11 t0 t13 t10 t11 t11 t13 t13
t18   r3(x) t10 t0 t11 t0 t13 t10 t11 t11 t13 t13
t19  c2  t10 t0 t11 t0 t13 t10 t11 t11 t13 t13
t20   c3 t10 t0 t11 t0 t13 t10 t11 t11 t13 t13
El protocolo de multiversión sí que acepta el plan. Fijaos que en la lectura r3(x) (en la que fallaba el plan en el
protocolo OMT) el valor que lee T3 es x2 (que es la versión de x creada por una transacción más joven anterior
a T3), la marca de lectura de esta versión de x no es actualizada porque ha sido leído por una transacción más
joven que T3 (T2).
![Page 9, Figure 1](../../public/subject-assets/Dbd/Teoria/Tema 4/Cuestiones _T4_sol/Cuestiones _T4_sol_page_009.png)
