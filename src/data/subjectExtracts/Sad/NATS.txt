# Extracted content
Source: subjects/Sad/NATS.pdf

### Page 1
NATS

### Page 2
Seminar Objectives
• Introduce NATS as a technology to connect services
• Explain main NATS concepts
• Use examples of usage
• Gain practical skills with NATS
https://docs.nats.io

### Page 3
Contents
• Core NATS
• Pub Sub
• Load Balancing
• Services
• Jetstream
• KV Store
• Object Store
• Advanced configurations

### Page 4
NATS: Setup for seminar
• Use docker to run the server locally
• docker run –-name nats -it –p 4222:4222 nats --js
• Add a “-d” flag if run in the background
• See: https://github.com/nats-io/natscli/releases

### Page 5
Ephemeral Messaging
Core NATS
01

### Page 6
Core NATS
• PUB/SUB model: At most once semantics
• Producers publish messages to subjects
• Consumers can subscribe to subjects
• A consumer receives a message if it is subscribed when the
message is published
• Addressing based on subject (topic)
• Volatile, but ordered
• Clustering/Fault tolerance/Scalability techniques

### Page 7
Several patterns
• PUB/SUB
• Load Balancing: Queue Groups
• Request-Reply

### Page 8
Basic PUB/SUB

### Page 9
PUB/SUB: Messages
• A subject
• A byte array as Payload
• Any number of header fields
• An optional reply address field
• Maximum size can be configured
• 1 MB default
• 64 MB limit
• 8 MB recommended

### Page 10
PUB/SUB: subject addressing

### Page 11
PUB/SUB: Subject names
• Tokenized, separated by “.”
• Token allowed characters
• Any Unicode, except “.”, “*”, and “>”
• Reserved names start with “$”
• $SYS
• $JS
• $KV
• …

### Page 12
Exercise

### Page 13
Exercise
• Create subscriber 1 (on its own terminal)
• Create a publisher and publish message
• More subscribers (use different terminals)
• nats sub com.msg.one
• nats pub com.msg.one “This is a simple message”
• nats pub com.msg.one “This is another  simple message”
• nats sub com.msg.one
• nats sub com.msg.one

### Page 14
Exercise: subject wildcards
• Create simple wildcard subscriber
• Create a publisher and publish message
• Single-token wildcard (many)
• nats sub com.msg.*
• nats pub com.msg.one “Hi”
• nats pub com.msg.one.two “Do you see me?”
• nats sub com.msg.*.two
• Multi-token wildcard (only at the end)
• nats sub com.msg.>
• nats pub com.msg.one.two “Do you see me now?”

### Page 15
Request/Reply

### Page 16
Request/Reply
• Built on top of basic PUB/SUB
• Requests sent on a request subject
• Reply subject dynamically created: _INBOX.<random>
• Requester subscribes to reply subject
• Replier subscribes to request subject
• Requests sent on a request subject
• Replier publishes to dynamic reply subject
• Reply subject is found in headers

### Page 17
Request/Reply
• Can have multiple repliers
• Repliers can be grouped
• Only the first arriving reply is considered
• Only one in the group receives each request
• Can scale up/down
• Repliers must drain messages to avoid request loss on downscale

### Page 18
Exercise
• Create replier (on its own terminal)
• Perform a request
• Subscribe to all (in its own terminal)
• nats reply com.request.hello world
• nats request com.request.hello world
• nats sub ”>”
• Look at the traffic generated
• nats request com.request.hello world

### Page 19
Exercise
• Create replier with command
• Perform a request
• Inspect body
• nats reply ‘hello.*’ —command “echo Hello {{1}}”
• nats request hello.peter ‘’
• nats reply ‘hello.*’ –command “echo {{.Request}} {{1}}”
• Perform another request
• nats request hello.Don Hello

### Page 20
Queue Groups
• Subscribers subscribe as part of a named “queue”
• Queue Group = all subscribers part of a queue
• Only one subscriber in the group gets a given message
• All queue groups get all messages to the subject
• Randomly selected
• Load balancing within each group
• Also applies to repliers
• Names follow same rules as subject names

### Page 21
Queue group

### Page 22
Exercise
• Create two subscribers (each on its own terminal)
• Create a subscriber on a different group
• Send several requests
• nats sub –queue test hello
• nats sub –queue notest hello
• nats pub –count hello “Hi {{.Count}}”
• nats sub –queue test hello

### Page 23
Exercise
• Create two repliers (each on its own terminal)
• Create a replier on a different group
• Send several requests
• nats reply –queue test hello –command “echo 1 {{.Request}}”
• nats reply –queue notest hello –command “echo 0 {{.Request}}”
• nats request –count hello “Hi {{.Count}}”
• nats reply –queue test hello –command “echo 2 {{.Request}}”

### Page 24
Persistence in NATS
Jetstream
01

### Page 25
Overview
• NATS persistence engine
• Messages can be stored and replayed at a later time
• In a cluster of NATS servers, data can be replicated
• Key Value store can be built on top
• Object Store can be built on top
• Late arriving consumers can still receive messages
• Helps handle failures
• At client library level (no server changes)
• At client library level (no server changes)

### Page 26
Streams
• Stream == Named and ordered message store
• Defines means of storage
• Imposes limits
• In memory
• In File
• Degree of replication (1 .. 5) among servers
• By means of Raft consistency protocol
• Retention policy
• Discard Policy (old out or new blocked)
• Message de-duplication
• Within a sliding window
Details: https://docs.nats.io/nats-concepts/jetstream/streams#configuration
• Consumes normal NATS Subjects

### Page 27
Retention Policies
• Limits Policy
• When hit, automatic deletion of message
• Each message can be consumed only once
• ➔Only one consumer per subject
• If no consumers exist, published messages are deleted
• Once a message is acked by all consumers, it is deleted
• MaxBytes, MaxAge, MaxMsgsPerSubject
• Work Queue Policy
• Once acked, the message is deleted
• Interest Policy

### Page 28
Consumer
• Stateful view of a stream
• Interface for clients to consume
• Keeps track of which messages are ACKed by clients
• Responsible of tracking delivery and acks
• Automatic redeliver attempt if not delivered
• Lives in server
• Various ack types and policies
• Dispatch types
• Persistence

### Page 29
Dispatch type: Push/Pull
• Push - based
• Use case:
• Simple app that need to access all messages in order
• Consumer delivers message immediately
• Pull - based
• Use case:
• Application controls, and can scale
• Client requests messages from consumer
• Potentially in batches
• Also above use case

### Page 30
Persistence: ephemeral/durable
• Ephemeral
• Automatically deleted after inactivity (no subscribers)
• Server memory only: not persisted.
• Durable
• Can be cleaned up if inactive
• If InactiveThreshold is set
• Same replication factor as their stream
• Can recover from server/client failures
• When Durable field is set
• Or InactiveThreshold is set
Details: https://docs.nats.io/nats-concepts/jetstream/consumers#configuration

### Page 31
Example
nats stream add ORDERS--subjects "ORDERS.*"--ack --max-msgs=-1 --max-bytes=-1 --max-age=1y --storage file --retentionlimits --max-msg-size=-1 --discard=old
nats consumeradd ORDERSNEW --filter ORDERS.received--ack explicit --pull --deliver all --max-deliver=-1 --sample 100
nats consumeradd ORDERSDISPATCH--filter ORDERS.processed--ack explicit --pull --deliver all --max-deliver=-1 --sample 100
nats consumeradd ORDERSMONITOR--filter '' --ack none --target monitor.ORDERS--deliver last --replay instant

### Page 32
Example
• Create a stream
• nats stream add sogreat
• Publish to the subjects of the stream
• nats pub fantastic thatis
• Set subjects fantastic, horrible.>
• nats pub horrible.my.gosh thatis
• Verify info
• nats info sogreat
• We can see there are two messages in stream
• Normal subscribers cannot access the stream
• Only new messages

### Page 33
Example
• Create a consumer
• nats consumer add
• Set the name: marvel
• Subscribe
• nats consumer next sogreat marvel –count 100
• We can see we are retrieving the messages we sent
• Accept the defaults
• nats consumer next sogreat marvel –count 100
• No new messages appear

### Page 34
Example
• We can replay: creating another consumer
• nats consumer add …
• Or removing old consumer and recreating it
• Clean up
• nats stream purge sogreat
• nats stream rm sogreat
• nats consumer rm marvel
• nats consumer add …

### Page 35
Key Value Store
• Built on top of Jetstream
• Builds an immediately consistent map
• A KV bucket corresponds to a stream
• Operations on a bucket
• put associates a value with a key
• get retrieves the value associated with a key
• delete remove any value associated with a key
• purge remove all values associated with all keys
• keys get all the keys with the operations associated

### Page 36
KV Store: concurrency control
• Operations that verify a condition and mutate atomically
• create associates a value with a key
• update compare and set the value for a key
• Only if the key does not exist
• Fails if the revision provided is not the current one for the key

### Page 37
KV Store: stream operations
• Getting streams
• watch receives changes for a key (with wildcards)
• watch all receive changes for all the keys in the bucket
• Similar to a subscription
• history list of the values and deletes for each key over time
• By default, history of buckets set to 1.
• Only the latest value/operation is stored

### Page 38
Example
• Creating a KV Bucket
• nats kv create almacen pala.troca grande
• Setting a value
• nats kv add almacen
• nats kv create almacen pala.troca grande
• Delete a key
• nats kv del almacen pala.troca
• Watch a store or key
• nats kv watch almacen
• nats kv watch almacen “pala.>”

### Page 39
Object Store
• Built on top of Jetstream
• Builds a set of files or arbitrary size
• An Object bucket corresponds to a stream
• Operations on a bucket
• put adds a file to a bucket
• get retrieves a file and stores in a designated location
• Stored as a collection of chunks
• del removes a file
• All files in a bucket must fit in a file system
• Not a distributed storage system
• watch informs of changes in a bucket

### Page 40
Example
• Creating an Object Bucket
• nats object put pueblo archie.zip
• Storing a file
• nats object add pueblo
• nats object put –name archivo.zip pueblo archie.zip
• Retrieving a file
• nats object get pueblo archivo.zip
• nats object get –output archie.zip pueblo archivo.zip

### Page 41
Q & A
