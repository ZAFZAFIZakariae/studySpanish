# T1 · Hand-Crafted Feature Extraction

## Objetivos de la lección
- Diferenciar descriptores globales y locales para representar imágenes.
- Repasar métricas estadísticas clásicas para caracterizar texturas.
- Comprender el funcionamiento de LBP, HOG, SIFT y filtros de Gabor.
- Identificar fortalezas y limitaciones de las características diseñadas manualmente.

## Esquema de contenidos
- Introducción y fundamentos de los descriptores.
- Estadísticos de primer y segundo orden.
- Local Binary Patterns (LBP) y sus variantes invariantes.
- Histogram of Oriented Gradients (HOG).
- Descriptores basados en puntos clave: SIFT.
- Bancos de filtros y respuestas en frecuencia (Gabor).

![Panorama de descriptores clásicos](figure:admeav/t1-taxonomy)
Caption: Relación entre descriptores globales, locales y basados en puntos clave utilizados en visión clásica.

## ¿Qué es una característica?
- Valor numérico que captura un aspecto relevante (color, textura, forma) de una imagen completa o de una región.
- Debe ser **discriminativa** (valores cercanos para ejemplos similares) y **robusta** frente a ruido o cambios moderados.
- Normalmente se combinan en **vectores de características** para describir objetos o escenas.

## Metodología de extracción
- **Descriptores globales**: se calculan sobre la imagen completa (histogramas de color, momentos geométricos).
- **Descriptores locales**: se aplican sobre regiones o puntos clave.
  - División en parches regulares.
  - Detección de landmarks (Harris, DoG) y posterior descripción.
- Pipeline típico: detección → descripción → agregación (bag-of-words, concatenación).

## Estadísticos clásicos
- **Primer orden** (histograma): media, varianza, asimetría, curtosis, entropía.
- **Segundo orden** (matriz de co-ocurrencias): captura dependencia espacial entre intensidades.
  - La matriz de co-ocurrencias se denota como P(i, j; d) y cuenta los pares de píxeles separados por un desplazamiento vectorial d = d(i, j) con niveles de gris i y j.
- **Órdenes superiores**: modelados complejos (momento centralizado, cumulantes).

## Local Binary Patterns
- Comparan cada píxel con sus vecinos: valores mayores reciben 1, menores 0; el patrón binario describe la textura.
- Se parametriza con **P vecinos** y **radio R**. Se generan histogramas de patrones para caracterizar una región.
  - Ejemplos habituales: P = 8, R = 1; P = 16, R = 2; P = 8, R = 2.
  - La operación ROR(x, t) realiza t rotaciones del patrón x para obtener el código mínimo; con P = 8 hay 256 patrones y 36 clases invariantes a rotación.
- Variantes:
  - **LBPri**: agrupa patrones equivalentes bajo rotaciones.
  - **LBPriu2**: se queda con patrones uniformes (máximo dos transiciones) para reducir dimensionalidad.
- Útiles para texturas finas y robustos a cambios de iluminación suaves.

## Histogram of Oriented Gradients
- Divide la imagen en celdas, calcula gradientes y acumula orientaciones ponderadas por magnitud.
- Normaliza bloques contiguos para ganar invariancia a iluminación y contraste.
- Popular en detección de peatones y objetos rígidos gracias a su sensibilidad a bordes.

### Flujo general del descriptor
1. Cálculo de gradientes.
2. Agrupación de las orientaciones en histogramas por celda.
3. Construcción de vectores por bloque concatenando celdas adyacentes.
4. Normalización de cada bloque antes de formar el descriptor global.

### Ejemplo de convolución inicial
- Píxel de entrada 8×8 tomado del ejemplo de las diapositivas:
  - Filas: [74 66 62 59 63 71 75 72], [72 65 61 58 62 70 75 72], [71 68 63 59 63 69 73 69], [70 67 62 59 62 69 73 69], [70 64 59 57 61 70 74 72], [68 66 64 63 65 68 69 68], [70 69 67 66 67 69 69 67], [69 68 66 64 65 67 66 63].
- Kernel Sobel horizontal:
  - Filas: [-1 0 1], [-2 0 2], [-1 0 1].
- Convolución discreta: y[m, n] = Σₖ Σₗ x[k, l] · h[m - k, n - l]; en el ejemplo el píxel central vale aproximadamente 3.

### Cálculo de gradientes
- Filtro Sobel horizontal Gₓ:
  - Filas: [-1 0 1], [-2 0 2], [-1 0 1].
- Filtro Sobel vertical Gᵧ:
  - Filas: [-1 -2 -1], [0 0 0], [1 2 1].
- Magnitud: |G| = √(Gₓ² + Gᵧ²).
- Orientación: θ = atan2(Gᵧ, Gₓ).

### Interpolación angular
- Problemas: gradientes casi iguales pueden caer en bins distintos y pequeñas variaciones de orientación alteran el histograma.
- Solución: repartir cada gradiente entre los dos intervalos más cercanos en proporción a la distancia del ángulo al centro del bin.
- Ejemplo de las diapositivas: para g(x, y) = 100 y θ(x, y) = 45° con 9 bins en [0°, 180°) sin signo, la contribución se reparte como [0, 25, 75, 0, 0, 0, 0, 0, 0].

### Integración espacial
- Problema: píxeles próximos pueden caer en celdas diferentes y pequeñas variaciones de forma alteran los histogramas.
- Solución: cada píxel se distribuye entre las cuatro celdas más cercanas ponderando por la distancia al centro de cada celda (interpolación bilineal).

### Normalización por bloques y descriptor final
- Agrupar b × b celdas para formar un vector de bloque v = (x₁, x₂, …, xₙ).
- Normalización L2: v' = v / √(x₁² + x₂² + … + xₙ² + ε²).
- El descriptor HOG final se obtiene concatenando todos los vectores normalizados: HOG = (x₁, x₂, …, x_N).

## SIFT
- Detecta puntos clave mediante diferencias de gaussianas en escala y localiza extremos subpíxel.
- Asigna orientación dominante para lograr invariancia a rotación.
- Describe cada punto con histogramas de gradiente locales (128 dimensiones clásicas).
- Estable para correspondencias entre imágenes con cambios de escala, rotación y moderados cambios de iluminación.

### Detección de extremos DoG
- Pirámide de escalas basada en una σ₀ inicial y factores k por octava.
- Diferencia de Gaussianas: D(x, y, σ) = L(x, y, kσ) - L(x, y, σ).
- Suavizado previo: L(x, y, σ) = G(x, y, σ) * I(x, y).

### Asignación de orientación y descriptor
- Magnitud del gradiente alrededor del punto clave:
  - m(x, y) = √((L(x + 1, y) - L(x - 1, y))² + (L(x, y + 1) - L(x, y - 1))²).
- Orientación local:
  - θ(x, y) = atan2(L(x, y + 1) - L(x, y - 1), L(x + 1, y) - L(x - 1, y)).
- Las contribuciones al histograma se ponderan con una gaussiana de desviación σ = 1.5·s para suavizar.

### Emparejamiento de descriptores
- Distancia euclídea al cuadrado (SSD) entre descriptores: SSD(f₁, f₂) = Σᵢ (f₁,ᵢ - f₂,ᵢ)².

## Filtros de Gabor
- Simulan receptores de la corteza visual: senos modulados por gaussianas.
- Responden a frecuencias y orientaciones específicas; bancos multiescala capturan texturas.
- Útiles en reconocimiento facial, análisis de texturas y biometría.

## Ventajas y limitaciones
- **Ventajas**: interpretables, requerimientos de datos moderados, buen rendimiento en dominios controlados.
- **Limitaciones**: sensibilidad a transformaciones complejas, dificultad para generalizar sin ingeniería manual, dimensionalidad alta al combinar múltiples descriptores.

## Detector de esquinas de Harris
- Matriz de estructura para cada píxel: C(x) = Σ_{(u,v) ∈ Nₓ} [Ix(u,v)² Ix(u,v) Iy(u,v); Ix(u,v) Iy(u,v) Iy(u,v)²].
- Interpretación mediante autovalores:
  - λ₁ y λ₂ grandes ⇒ esquina.
  - λ₁ grande y λ₂ pequeña (o viceversa) ⇒ borde.
  - Ambos pequeños ⇒ región plana.
- Factorización: C(x) = R⁻¹ diag(λ₁, λ₂) R, donde R alinea los ejes con los autovectores.

## Emparejamiento de características
- Correlación normalizada entre ventanas centradas en x₁ y x₂: R(x₁, x₂) = Σ_{(u,v) ∈ N} s₁(u,v) s₂(u,v) / (√(Σ_{(u,v) ∈ N} s₁(u,v)²) · √(Σ_{(u,v) ∈ N} s₂(u,v)²)).
- Se buscan emparejamientos putativos y posteriormente se aplica un método robusto (p.ej., RANSAC) para filtrar outliers.
