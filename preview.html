<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Subject Extract Preview</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background-color: #f5f5f5;
      }

      body {
        margin: 0;
        padding: 1.5rem;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.9));
        min-height: 100vh;
      }

      h1 {
        margin-top: 0;
        font-size: clamp(1.8rem, 2vw + 1rem, 2.5rem);
      }

      main {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: minmax(240px, 320px) minmax(0, 1fr);
        align-items: start;
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.08);
        padding: 1.5rem;
        border: 1px solid rgba(0, 0, 0, 0.05);
        backdrop-filter: blur(5px);
      }

      .panel h2 {
        margin-top: 0;
        font-size: 1.1rem;
        letter-spacing: 0.02em;
      }

      .status {
        font-size: 0.9rem;
        color: #555;
        margin-top: 0.5rem;
        line-height: 1.4;
      }

      select,
      button {
        width: 100%;
        padding: 0.6rem 0.75rem;
        font-size: 1rem;
        border-radius: 0.6rem;
        border: 1px solid rgba(0, 0, 0, 0.15);
        background-color: rgba(255, 255, 255, 0.85);
        cursor: pointer;
      }

      button:hover,
      select:hover {
        border-color: rgba(59, 130, 246, 0.6);
      }

      #content article {
        font-size: 1rem;
        line-height: 1.6;
        color: #1a1a1a;
        white-space: pre-wrap;
      }

      .notes {
        padding-left: 1.25rem;
      }

      .notes li {
        margin-bottom: 0.25rem;
      }

      .metadata dt {
        font-weight: 600;
        margin-top: 0.75rem;
      }

      .metadata dd {
        margin: 0.25rem 0 0.5rem 0;
        color: #333;
      }

      .markdown-body {
        font-size: 1rem;
        line-height: 1.65;
        color: #1f1f1f;
      }

      .markdown-body pre,
      .markdown-body code {
        background-color: rgba(15, 23, 42, 0.05);
        padding: 0.15rem 0.35rem;
        border-radius: 0.3rem;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      }

      .markdown-body pre {
        overflow-x: auto;
        padding: 0.75rem;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Subject Extract Preview</h1>
      <p class="status" id="status">Loading subject extracts…</p>
    </header>
    <main>
      <section class="panel">
        <h2>Available extracts</h2>
        <label for="extractSelect" class="hidden">Choose an extract</label>
        <select id="extractSelect" aria-label="Choose an extract"></select>
        <button id="openSource" type="button" disabled>Open original asset</button>
      </section>
      <section class="panel" id="content">
        <h2 id="contentTitle">Extract details</h2>
        <dl class="metadata">
          <dt>Source asset</dt>
          <dd id="source">—</dd>
          <dt class="notes-heading hidden">Extraction notes</dt>
          <dd>
            <ul class="notes" id="notes"></ul>
          </dd>
        </dl>
        <article id="rendered" class="markdown-body"></article>
      </section>
    </main>

    <script type="module">
      const select = document.getElementById('extractSelect');
      const status = document.getElementById('status');
      const sourceEl = document.getElementById('source');
      const notesEl = document.getElementById('notes');
      const notesHeading = document.querySelector('.notes-heading');
      const rendered = document.getElementById('rendered');
      const openSourceButton = document.getElementById('openSource');

      const headerRegex = /^# Extracted content\r?\nSource: (?<source>subjects\/[\s\S]+?)\r?\n(?:Notes:\r?\n(?<notes>(?:- .+\r?\n)+))?/;

      const encodePath = (path) =>
        path
          .split('/')
          .map((segment) => encodeURIComponent(segment))
          .join('/');

      const fetchManifest = async () => {
        const response = await fetch('/subject-extracts.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Unable to load manifest (${response.status})`);
        }
        return response.json();
      };

      const parseExtract = (rawText) => {
        const match = rawText.match(headerRegex);
        if (!match?.groups?.source) {
          return {
            source: 'Unknown source',
            text: rawText.trim(),
            notes: [],
          };
        }

        const notesBlock = match.groups.notes;
        const notes = notesBlock
          ? notesBlock
              .trim()
              .split(/\r?\n/)
              .map((line) => line.replace(/^-\s*/, '').trim())
              .filter(Boolean)
          : [];

        const text = rawText.replace(headerRegex, '').trim();
        return { source: match.groups.source.trim(), text, notes };
      };

      let markedRenderer;
      const ensureMarked = async () => {
        if (markedRenderer) return markedRenderer;
        try {
          const mod = await import('https://esm.sh/marked@12.0.1');
          markedRenderer = mod.marked || mod.default || mod;
        } catch (error) {
          console.warn('Falling back to plain text rendering:', error);
        }
        return markedRenderer;
      };

      const renderExtract = async (extract) => {
        sourceEl.textContent = extract.source;

        if (extract.notes.length > 0) {
          notesHeading?.classList.remove('hidden');
          notesEl.innerHTML = '';
          for (const note of extract.notes) {
            const li = document.createElement('li');
            li.textContent = note;
            notesEl.appendChild(li);
          }
        } else {
          notesHeading?.classList.add('hidden');
          notesEl.innerHTML = '';
        }

        const renderer = await ensureMarked();
        if (renderer) {
          rendered.innerHTML = renderer.parse ? renderer.parse(extract.text) : renderer(extract.text);
        } else {
          rendered.textContent = extract.text;
        }
      };

      const fetchExtract = async (path) => {
        const response = await fetch(encodePath(path));
        if (!response.ok) {
          throw new Error(`Unable to load extract (${response.status})`);
        }
        return response.text();
      };

      const updateSourceButton = (extract) => {
        if (extract?.source) {
          openSourceButton.disabled = false;
          openSourceButton.onclick = () => {
            const url = encodePath(`/${extract.source}`);
            window.open(url, '_blank', 'noopener');
          };
        } else {
          openSourceButton.disabled = true;
          openSourceButton.onclick = null;
        }
      };

      const initialise = async () => {
        try {
          const manifest = await fetchManifest();
          const files = manifest.files ?? [];

          if (files.length === 0) {
            status.textContent = 'No subject extracts were found.';
            return;
          }

          for (const file of files) {
            const option = document.createElement('option');
            option.value = file.path;
            option.textContent = file.label;
            select.appendChild(option);
          }

          select.addEventListener('change', async () => {
            const path = select.value;
            if (!path) return;
            status.textContent = `Loading ${path}…`;
            rendered.textContent = '';
            openSourceButton.disabled = true;
            openSourceButton.onclick = null;
            try {
              const raw = await fetchExtract(path);
              const extract = parseExtract(raw);
              await renderExtract(extract);
              updateSourceButton(extract);
              status.textContent = `Showing ${path}`;
            } catch (error) {
              console.error(error);
              status.textContent = `Unable to load ${path}`;
            }
          });

          // Auto-load the first extract
          select.value = files[0].path;
          select.dispatchEvent(new Event('change'));
        } catch (error) {
          console.error(error);
          status.textContent = 'Failed to load subject extract list. Run `npm run preview` and try again.';
        }
      };

      initialise();
    </script>
  </body>
</html>
